/*
 * generated by Xtext 2.10.0
 */
package kcl.ac.uk.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import kcl.ac.uk.xtext.annotationsStores.AnnotationStores;
import kcl.ac.uk.xtext.annotationsStores.AnnotationsStoresPackage;
import kcl.ac.uk.xtext.annotationsStores.ArgumentStore;
import kcl.ac.uk.xtext.annotationsStores.ChallengeStore;
import kcl.ac.uk.xtext.annotationsStores.CommitmentStore;
import kcl.ac.uk.xtext.annotationsStores.Effect;
import kcl.ac.uk.xtext.annotationsStores.Focus;
import kcl.ac.uk.xtext.annotationsStores.ProposalStore;
import kcl.ac.uk.xtext.annotationsStores.QuestionStore;
import kcl.ac.uk.xtext.annotationsStores.Scope;
import kcl.ac.uk.xtext.services.AnnotationsStoresGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AnnotationsStoresSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AnnotationsStoresGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AnnotationsStoresPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AnnotationsStoresPackage.ANNOTATION_STORES:
				sequence_AnnotationStores(context, (AnnotationStores) semanticObject); 
				return; 
			case AnnotationsStoresPackage.ARGUMENT_STORE:
				sequence_ArgumentStore(context, (ArgumentStore) semanticObject); 
				return; 
			case AnnotationsStoresPackage.CHALLENGE_STORE:
				sequence_ChallengeStore(context, (ChallengeStore) semanticObject); 
				return; 
			case AnnotationsStoresPackage.COMMITMENT_STORE:
				sequence_CommitmentStore(context, (CommitmentStore) semanticObject); 
				return; 
			case AnnotationsStoresPackage.EFFECT:
				sequence_Effect(context, (Effect) semanticObject); 
				return; 
			case AnnotationsStoresPackage.FOCUS:
				sequence_Focus(context, (Focus) semanticObject); 
				return; 
			case AnnotationsStoresPackage.PROPOSAL_STORE:
				sequence_ProposalStore(context, (ProposalStore) semanticObject); 
				return; 
			case AnnotationsStoresPackage.QUESTION_STORE:
				sequence_QuestionStore(context, (QuestionStore) semanticObject); 
				return; 
			case AnnotationsStoresPackage.SCOPE:
				sequence_Scope(context, (Scope) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AnnotationStores returns AnnotationStores
	 *
	 * Constraint:
	 *     (
	 *         (proposalElements+=ProposalStore+ ((challengeElements+=ChallengeStore+ argumentElements+=ArgumentStore+) | argumentElements+=ArgumentStore+)) | 
	 *         (
	 *             ((proposalElements+=ProposalStore+ questionElements+=QuestionStore+) | questionElements+=QuestionStore+) 
	 *             ((challengeElements+=ChallengeStore+ argumentElements+=ArgumentStore+) | argumentElements+=ArgumentStore+)
	 *         ) | 
	 *         (
	 *             (
	 *                 (proposalElements+=ProposalStore+ ((questionElements+=QuestionStore+ challengeElements+=ChallengeStore+) | challengeElements+=ChallengeStore+)) | 
	 *                 (questionElements+=QuestionStore+ challengeElements+=ChallengeStore+) | 
	 *                 challengeElements+=ChallengeStore+
	 *             )? 
	 *             commitmentElements+=CommitmentStore+ 
	 *             argumentElements+=ArgumentStore+
	 *         ) | 
	 *         (challengeElements+=ChallengeStore+ argumentElements+=ArgumentStore+) | 
	 *         argumentElements+=ArgumentStore+
	 *     )?
	 */
	protected void sequence_AnnotationStores(ISerializationContext context, AnnotationStores semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArgumentStore returns ArgumentStore
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         scope=Scope 
	 *         focus=Focus 
	 *         content=STRING 
	 *         target=ID? 
	 *         effect=Effect?
	 *     )
	 */
	protected void sequence_ArgumentStore(ISerializationContext context, ArgumentStore semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ChallengeStore returns ChallengeStore
	 *
	 * Constraint:
	 *     (name=ID sender=Sender target=ID? effect=Effect?)
	 */
	protected void sequence_ChallengeStore(ISerializationContext context, ChallengeStore semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommitmentStore returns CommitmentStore
	 *
	 * Constraint:
	 *     (name=ID scope=Scope focus=Focus content=STRING effect=Effect?)
	 */
	protected void sequence_CommitmentStore(ISerializationContext context, CommitmentStore semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Effect returns Effect
	 *
	 * Constraint:
	 *     affectedBy=ID
	 */
	protected void sequence_Effect(ISerializationContext context, Effect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AnnotationsStoresPackage.Literals.EFFECT__AFFECTED_BY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AnnotationsStoresPackage.Literals.EFFECT__AFFECTED_BY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEffectAccess().getAffectedByIDTerminalRuleCall_0(), semanticObject.getAffectedBy());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Focus returns Focus
	 *
	 * Constraint:
	 *     (focus='R' | focus='S' | focus='G' | focus='V' | focus='A')
	 */
	protected void sequence_Focus(ISerializationContext context, Focus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProposalStore returns ProposalStore
	 *
	 * Constraint:
	 *     (name=ID scope=Scope focus=Focus content=STRING effect=Effect?)
	 */
	protected void sequence_ProposalStore(ISerializationContext context, ProposalStore semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QuestionStore returns QuestionStore
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         sender=Sender 
	 *         scope=Scope 
	 *         focus=Focus 
	 *         content=STRING 
	 *         effect=Effect?
	 *     )
	 */
	protected void sequence_QuestionStore(ISerializationContext context, QuestionStore semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns Scope
	 *
	 * Constraint:
	 *     (scope='feature' | scope='rating' | scope='criteria' | scope='topic')
	 */
	protected void sequence_Scope(ISerializationContext context, Scope semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
